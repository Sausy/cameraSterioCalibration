# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from roboy_middleware_msgs/XL320Request.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class XL320Request(genpy.Message):
  _md5sum = "d0b3c3391dc54fe3a913cbf9ecf628c0"
  _type = "roboy_middleware_msgs/XL320Request"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# 0: read 1:write
bool type
uint8 motor
# EEPROM Area
# MODEL_NUMBER             = 0, /**< Model number [R] (default=350) */
# VERSION                  = 2, /**< Information on the version of firmware [R] */
# id                       = 3, /**< id of Dynamixel [RW] (default=1 ; min=0 ; max=252) */
# BAUD_RATE                = 4, /**< Baud Rate of Dynamixel [RW] (default=3 ; min=0 ; max=3) 0: 9600, 1:57600, 2:115200, 3:1Mbps*/
# RETURN_DELAY_TIME        = 5, /**< Return Delay Time [RW] (default=250 ; min=0 ; max=254) */
# CW_ANGLE_LIMIT           = 6, /**< clockwise Angle Limit [RW] (default=0 ; min=0 ; max=1023) */
# CCW_ANGLE_LIMIT          = 8, /**< counterclockwise Angle Limit [RW] (default=1023 ; min=0 ; max=1023) */
# CONTROL_MODE             = 11, /**< Control Mode [RW] (default=2 ; min=1 ; max=2) */
# LIMIT_TEMPERATURE        = 12, /**< Internal Limit Temperature [RW] (default=65 ; min=0 ; max=150) */
# LOWER_LIMIT_VOLTAGE      = 13, /**< Lowest Limit Voltage [RW] (default=60 ; min=50 ; max=250) */
# UPPPER_LIMIT_VOLTAGE     = 14, /**< Upper Limit Voltage [RW] (default=90 ; min=50 ; max=250) */
# MAX_TORQUE               = 15, /**< Lowest byte of Max. Torque [RW] (default=1023 ; min=0 ; max=1023) */
# RETURN_LEVEL             = 17, /**< Return Level [RW] (default=2 ; min=0 ; max=2) */
# ALARM_SHUTDOWN           = 18, /**< Shutdown for Alarm [RW] (default=3 ; min=0 ; max=7) */
# RAM Area
# TORQUE_ENABLE            = 24, /**< Torque On/Off [RW] (default=0 ; min=0 ; max=1) */
# LED                      = 25, /**< LED On/Off [RW] (default=0 ; min=0 ; max=7) */
# D_GAIN    				 = 27, /**< D Gain [RW] (default=0 ; min=0 ; max=254) */
# I_GAIN      			 = 28, /**< I Gain [RW] (default=0 ; min=0 ; max=254) */
# P_GAIN    				 = 29, /**< P Gain [RW] (default=32 ; min=0 ; max=254) */
# GOAL_POSITION            = 30, /**< Goal Position [RW] (min=0 ; max=1023) */
# GOAL_SPEED               = 32, /**< Goal Speed [RW] (min=0 ; max=2047) */
# GOAL_TORQUE 		     = 35, /**< Goal Torque [RW] (min=0 ; max=1023) */
# PRESENT_POSITION         = 37, /**< Current Position [R] */
# PRESENT_SPEED            = 39, /**< Current Speed [R] */
# PRESENT_LOAD             = 41, /**< Current Load [R] */
# PRESENT_VOLTAGE          = 45, /**< Current Voltage [R] */
# PRESENT_TEMPERATURE      = 46, /**< Present temperature [R] */
# REGISTERED_INSTRUCTION   = 47, /**< Registered Instruction [R] (default=0) */
# MOVING                   = 49, /**< Moving [R] (default=0) */
# HARDWARE_ERROR           = 50, /**< Hardware error status [R] (default=0) */
# PUNCH                    = 51  /**< Punch [RW] (default=32 ; min=0 ; max=1023) */
uint8 address
int16 value
"""
  __slots__ = ['type','motor','address','value']
  _slot_types = ['bool','uint8','uint8','int16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       type,motor,address,value

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(XL320Request, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.type is None:
        self.type = False
      if self.motor is None:
        self.motor = 0
      if self.address is None:
        self.address = 0
      if self.value is None:
        self.value = 0
    else:
      self.type = False
      self.motor = 0
      self.address = 0
      self.value = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3Bh().pack(_x.type, _x.motor, _x.address, _x.value))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 5
      (_x.type, _x.motor, _x.address, _x.value,) = _get_struct_3Bh().unpack(str[start:end])
      self.type = bool(self.type)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3Bh().pack(_x.type, _x.motor, _x.address, _x.value))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 5
      (_x.type, _x.motor, _x.address, _x.value,) = _get_struct_3Bh().unpack(str[start:end])
      self.type = bool(self.type)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3Bh = None
def _get_struct_3Bh():
    global _struct_3Bh
    if _struct_3Bh is None:
        _struct_3Bh = struct.Struct("<3Bh")
    return _struct_3Bh
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from roboy_middleware_msgs/XL320Response.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class XL320Response(genpy.Message):
  _md5sum = "55daaea9ec64e37c8a6144d42a7265e2"
  _type = "roboy_middleware_msgs/XL320Response"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int16 value
"""
  __slots__ = ['value']
  _slot_types = ['int16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       value

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(XL320Response, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.value is None:
        self.value = 0
    else:
      self.value = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.value
      buff.write(_get_struct_h().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 2
      (self.value,) = _get_struct_h().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.value
      buff.write(_get_struct_h().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 2
      (self.value,) = _get_struct_h().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_h = None
def _get_struct_h():
    global _struct_h
    if _struct_h is None:
        _struct_h = struct.Struct("<h")
    return _struct_h
class XL320(object):
  _type          = 'roboy_middleware_msgs/XL320'
  _md5sum = '2df206e3bbdc218ed0e86d48777a9fbf'
  _request_class  = XL320Request
  _response_class = XL320Response
